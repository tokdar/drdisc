---
title: "report15"
author: "Haoliang Zheng"
date: "2/22/2022"
output:
  pdf_document:
    toc: true
    toc_depth: 2
---

```{r setup, include=FALSE}
knitr::opts_knit$set(root.dir = "/Users/zhl/Desktop/drdisc")
knitr::opts_chunk$set(echo = TRUE)
knitr::opts_chunk$set(fig.align = 'center', 
                      fig.width=6, fig.height=7)

library(abind)
library(knitr)
library(latex2exp)
require(magrittr)
require(plyr)
library(tidyverse)
library(coda)
library(doParallel)
library(doMC) 
library(foreach)
library(doRNG)

adapt <- FALSE
bunch <- FALSE
N_para <- 6

registerDoMC(6)

par(mar = c(2,2,2,2))
```


```{r source, include=FALSE}
source("./codes/new-codes.R")
source("./codes/test-codes.R")
source("./codes/other-codes.R")

multi_chain_coda_noa <- function(result_multi, burn = 1000, N_para, p, order){
  coda_result <- list()
  matrix_result <- NULL
  for(i in 1:N_para){
    matrix_result <- NULL
    for(j in 1:order){
      for(k in 1:p){
        bijk <- matrix(result_multi[[i]]$b[j,k,], ncol = 1)
        colnames(bijk) <- paste0("b",j,k)
        matrix_result <- cbind(matrix_result, bijk)
      }
    }
    coda_result[[i]] <- mcmc(matrix_result, start = burn+1)
  }
  coda_result_list <- mcmc.list(coda_result)
  
  return(coda_result_list)
}

para_temp_plot <- function(adapt_PT_new, L, N_para = 6){
par(mar = c(2,2,2,2))
par(mfrow = c(N_para, 1))
for(i in 1:N_para){
  plot(adapt_PT_new[[i]]$temp[1,], type = "l", ylim=range(adapt_PT_new[[i]]$temp),
       main = paste0("starting point ", i))
  for(j in 2:L){
    lines(adapt_PT_new[[i]]$temp[j,], col=tcol(j,.5), lwd=2)
    }
  }
}
```

# data

```{r}
vote <- read.csv("./codes/vote_data.csv")
vote <- subset(vote, abs(from_requirement_threshold) < 0.5)
set.seed(1234)
train.ss <- sample(nrow(vote), 15e3)

preds <- model.matrix(~ #major.requirement 
                        + ISS.against.recommendation 
                      #+ shares.oustanding.base 
                      #+ special.meeting 
                      + analyst.coverage 
                      #+ institutional.ownership 
                      + past.stock.return 
                      + q 
                      + firm.size, 
                      data = vote)[,-1]
preds.train <- scale(preds[train.ss,])
x <- cbind(1, preds.train)
x.test <- cbind(1, scale(preds[-train.ss,],
                         center=attr(preds.train,"scaled:center"),
                         scale=attr(preds.train,"scaled:scale")))
dimnames(x)[[2]][1] <- "Intercept"
dimnames(x.test)[[2]][1] <- "Intercept"
x.names <- dimnames(x)[[2]]

y <- 2*vote[train.ss,"from_requirement_threshold"]
y.test <- 2*vote[-train.ss,"from_requirement_threshold"]

bunch <- FALSE
pos.est <- TRUE
```

```{r}
set.seed(123)
N_para <- 6
p <- 6
order <- 15
L <- 5

kbw <- 2/(order-1)
knots <- seq(-1,1,kbw)
bsd.sq <- (0.67*kbw)^2
gausskern <- lapply(knots, function(mu) return(function(x) return(exp(-0.5*(x-mu)^2/bsd.sq))))
get.poly.mat <- function(y) return(sapply(gausskern, function(f) f(y)))

yFn <- get.poly.mat

b_init <- replicate(N_para, matrix(rnorm(n = order*p, sd=5), order, p))
a_init <- replicate(N_para, rnorm(n = p, sd = 1.5))
```


Denote $y^*_l$ as the missing history for chain $l$, then swap probability
for chain 1 and 2 is:
$$
\alpha(1, 2) = 1 \wedge \frac{p_1(y, y^*_2 | \theta_2) * p_2(y, y^*_1 | \theta_1)}{p_1(y, y^*_1 | \theta_1) * p_2(y, y^*_2 | \theta_2)}
$$


# bdregjump_adapt_tempered_new

```{r eval=FALSE}
adapt_tempered_joint_new <- foreach(i = 1:N_para) %dorng%
  bdregjump_adapt_tempered(y=y, x=x, b=b_init[,,i], burn=0, nsamp=5000, thin=1, order = 15,
                     jump=list(a=a_init[,i], prec = 1, positive=pos.est,
                               persistence=0.68, update.jbw=FALSE),
                     adap=list(parallel = 5, alpha_star_PT = 0.234))
```

```{r}
load(file = "./report/report15/adapt_tempered_joint_new.RData")
```

## Trace plot

```{r temperednew, cache=TRUE}
adapt_tempered_joint_new_coda <- multi_chain_parallel_coda(adapt_tempered_joint_new, burn=0, N_para, p, order)

plot(adapt_tempered_joint_new_coda)
```

From the trace plot, we can see clear sign of swapping.

## Acceptance rate

Overall acceptance rate of Metropolis and swap for 6 different initializing points:

```{r}
sapply(1:6, function(x) adapt_tempered_joint_new[[x]]$acpt)[c(1,3),]
```

Average acceptance rate of swap for each pair of chains from 6 different initializing points:

```{r}
get.swap.ratio(adapt_tempered_joint_new)
```

According to the acceptance rate, we can see the result seems to be good.
The acceptance rate of swap is around the setting of 0.234.

I also check the last 10 computed acceptance probabilities from 6 different initializing points
to make sure that they are not taking values only 0 or 1.


```{r}
adapt_tempered_joint_new[[1]]$swap_accept_prob[,4991:5000]
adapt_tempered_joint_new[[2]]$swap_accept_prob[,4991:5000]
adapt_tempered_joint_new[[3]]$swap_accept_prob[,4991:5000]
adapt_tempered_joint_new[[4]]$swap_accept_prob[,4991:5000]
adapt_tempered_joint_new[[5]]$swap_accept_prob[,4991:5000]
adapt_tempered_joint_new[[6]]$swap_accept_prob[,4991:5000]
```

## Inverse temperature

One thing not ideal is that other four inverse temperatures are all close to 1.
However, the good thing is that they are not extremely close to 1. It seems
that they converge to 0.98, 0.96, 0.94 and 0.92.

```{r}
para_temp_plot(adapt_tempered_joint_new, 5, N_para)
```

```{r}
sapply(1:6, function(x) adapt_tempered_joint_new[[x]]$temp[,5000])
```


# bdregjump_adapt_tempered_new, alpha_star_PT = 0.1

```{r eval=FALSE}
adapt_tempered_joint_new_alpha01 <- foreach(i = 1:N_para) %dorng%
  bdregjump_adapt_tempered(y=y, x=x, b=b_init[,,i], burn=0, nsamp=5000, thin=1, order = 15,
                     jump=list(a=a_init[,i], prec = 1, positive=pos.est,
                               persistence=0.68, update.jbw=FALSE),
                     adap=list(parallel = 5, alpha_star_PT = 0.1))
```

```{r}
save(adapt_tempered_joint_new_alpha01, y, x, b_init, a_init, order,
     file = "./report/report14/adapt_tempered_joint_new_alpha01.RData")
```

```{r temperednew, cache=TRUE}
adapt_tempered_joint_new_alpha01_coda <- multi_chain_parallel_coda(adapt_tempered_joint_new_alpha01, burn=0, N_para, p, order)

plot(adapt_tempered_joint_new_alpha01_coda)
```

```{r}
sapply(1:6, function(x) adapt_tempered_joint_new_alpha01[[x]]$acpt)[c(1,3),]
```

```{r}
get.swap.ratio(adapt_tempered_joint_new_alpha01)
```

```{r}
para_temp_plot(adapt_tempered_joint_new_alpha01, 5, N_para)
```

```{r}
sapply(1:6, function(x) adapt_tempered_joint_new_alpha01[[x]]$temp[,5000])
```